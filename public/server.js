const express = require('express');
const app = express();
const multer = require('multer');
const fs = require('fs')
const { OpenAI } = require('openai');
const dotenv = require('dotenv');
const path = require('path');
const { Pinecone } = require('@pinecone-database/pinecone')
const mongoose = require('mongoose');
const ChatHistory = require('./chatHistory');
const proxyRoutes = require('./proxy.js');
const pdfParse = require('pdf-parse');
const mammoth = require('mammoth');
const xlsx = require('xlsx');
const cors = require('cors');


// CORS
app.use(cors({
    origin: 'http://localhost:3000', // Cho ph√©p origin t·ª´ ·ª©ng d·ª•ng frontend
}));

app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'main.html'));
});

app.use(express.static(path.join(__dirname, 'public')));


app.use(express.json({ limit: '10mb' }));
app.use('/', proxyRoutes);
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

mongoose.connect('mongodb://localhost:27017/chatbot')
    .then(() => console.log('AI ƒê√£ c√≥ n√£o ƒë·ªÉ nh·ªõ'))
    .catch(err => console.error('MongoDB l·ªói r·ªìi, m·∫•t tr√≠ nh·ªõ r·ªìi!', err));

dotenv.config();

const upload = multer({ dest: 'uploads/' });
const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY,
});


// Function ƒë·ªÉ extract JSON t·ª´ text
function extractJsonFromText(text) {
    const jsonBlockRegex = /```json\s*([\s\S]*?)```/gi;//T√¨m b·ªçc trong markdown
    const jsonBlocks = [];
    let match;

    while ((match = jsonBlockRegex.exec(text)) !== null) {
        try {
            const jsonData = JSON.parse(match[1]);
            if (jsonData.nodes && Array.isArray(jsonData.nodes)) {
                jsonBlocks.push({
                    raw: match[1],
                    parsed: jsonData,
                    startIndex: match.index,
                    endIndex: match.index + match[0].length
                });
            }
        } catch (e) {
            // Kh√¥ng ph·∫£i JSON h·ª£p l·ªá, b·ªè qua
        }
    }

    if (jsonBlocks.length === 0) {
        const jsonObjectRegex = /\{[\s\S]*?"nodes"\s*:\s*\[[\s\S]*?\]\s*[\s\S]*?\}/g;//tim ko b·ªçc trong markdown
        while ((match = jsonObjectRegex.exec(text)) !== null) {
            try {
                const jsonData = JSON.parse(match[0]);
                if (jsonData.nodes && Array.isArray(jsonData.nodes)) {
                    jsonBlocks.push({
                        raw: match[0],
                        parsed: jsonData,
                        startIndex: match.index,
                        endIndex: match.index + match[0].length
                    });
                }
            } catch (e) {
                // Kh√¥ng ph·∫£i JSON h·ª£p l·ªá, b·ªè qua
            }
        }
    }

    return jsonBlocks;
}
// Clean node ƒë·ªÉ n√≥ ko hi·ªán n8n nodes-base hay @n8n j ƒë√≥ n·ªØa
function cleanNodeType(nodeType) {
    if (!nodeType) return 'Unknown';

    let cleanType = nodeType
        .replace(/^n8n-nodes-base\./, '')
        .replace(/^@n8n\//, '')
        .replace(/^n8n-/, '');

    cleanType = cleanType
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        .replace(/([A-Z])([A-Z][a-z])/g, '$1 $2')
        .toLowerCase()
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    // Map m·ªôt s·ªë t√™n node ph·ªï bi·∫øn sang t√™n th√¢n thi·ªán h∆°n
    const typeMap = {
        'Http Request': 'HTTP Request',
        'Http Webhook': 'HTTP Webhook',
        'If': 'IF',
        'Set': 'Set',
        'Code': 'Code',
        'Merge': 'Merge',
        'Wait': 'Wait',
        'Schedule Trigger': 'Schedule',
        'Manual Trigger': 'Manual',
        'Webhook': 'Webhook'
    };

    return typeMap[cleanType] || cleanType;
}
// Th√™m th√¥ng tin node v√†o label trong Mermaid
function enhanceNodeLabels(mermaidCode, workflowData) {
    if (!workflowData || !workflowData.nodes) return mermaidCode;

    const nodeMap = {};
    workflowData.nodes.forEach(node => {
        nodeMap[node.id] = {
            name: node.name || '',
            type: cleanNodeType(node.type),
            operation: node.parameters?.operation || '',
            event: node.parameters?.event || '',
        };
    });

    const enhancedCode = mermaidCode.replace(/([A-Za-z0-9_-]+)(?:\["([^"]*)"\])?/g, (match, nodeId, currentLabel) => {
        const nodeInfo = nodeMap[nodeId];
        if (!nodeInfo) return match;

        if (/-->|==>|<-|->/.test(match)) return match;

        let suffix = '';
        if (nodeInfo.operation && nodeInfo.event) {
            suffix = `${nodeInfo.operation}/${nodeInfo.event}`;
        } else if (nodeInfo.operation || nodeInfo.event) {
            suffix = nodeInfo.operation || nodeInfo.event;
        }

        let label = '';
        if (nodeInfo.name !== nodeInfo.type && nodeInfo.name !== nodeId) {
            label = `${nodeInfo.name}  (${nodeInfo.type})\\n${suffix}`;
        } else {
            label = `${nodeInfo.type}\\n${suffix}`;
        }

        return `${nodeId}["${label}"]`;
    });

    return enhancedCode;
}

// Function ƒë·ªÉ convert JSON th√†nh Mermaid (chuy·ªÉn t·∫°i server khi ƒëƒÉng)
async function convertJsonToMermaid(workflowData) {
    const payload = {
        workflow_data: workflowData,
        params: {
            direction: 'LR',
            subgraph_direction: 'BT',
            show_credentials: false,
            show_key_parameters: true,
            subgraph_display_mode: 'subgraph'
        }
    };

    try {
        const res = await fetch('https://api-n8nmermaid.janwillemaltink.com/v2/mermaid/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(payload)
        });

        const data = await res.json();
        if (!res.ok) {
            throw new Error('API error: ' + JSON.stringify(data));
        }

        let code = data.mermaid_code || (data.diagrams && data.diagrams.main);
        if (!code) {
            throw new Error('No Mermaid code returned.');
        }

        // Clean up code
        code = code
            .replace(/([^\s@]+)@\{[^}]*label:\s*"([^"]+)"[^}]*\}/g, '$1["$2"]')
            .replace(/([^\s@]+)@\{[^}]*\}/g, '$1')
            .replace(/%%.*$/gm, '')
            .trim();
        code = enhanceNodeLabels(code, workflowData);// Th√™m th√¥ng tin node v√†o label trong Mermaid
        return code;
    } catch (error) {
        throw error;
    }
}

//L·∫•y l·ªãch s·ª≠ chata
app.get('/history', async (req, res) => {
    try {
        const sessionId = req.ip || 'default-session';
        console.log('üìñ Loading history for sessionId:', sessionId);

        if (!sessionId) return res.status(400).json({ error: 'Thi·∫øu sessionId' });

        const history = await ChatHistory.findOne({ sessionId });
        if (!history) {
            console.log('üìñ Kh√¥ng t√¨m th·∫•y l·ªãch s·ª≠ cho sessionId:', sessionId);
            return res.json({ messages: [] });
        }

        //Tr·∫£ v·ªÅ tin nh·∫Øn user v√† assistant
        const historyMessages = history.messages
            .filter(msg => msg.role === 'user' || msg.role === 'assistant')
            .map(msg => ({
                role: msg.role,
                content: msg.content,
                metadata: msg.metadata || {} // Tr·∫£ v·ªÅ metadata ƒë·ªÉ client render l·∫°i
            }));

        console.log('üìñ Tr·∫£ v·ªÅ', historyMessages.length, 'tin nh·∫Øn v·ªõi metadata');
        res.json({ messages: historyMessages });
    } catch (err) {
        console.error('L·ªói khi l·∫•y l·ªãch s·ª≠:', err);
        res.status(500).json({ error: 'L·ªói server khi l·∫•y l·ªãch s·ª≠' });
    }
});

// Load guild docs
async function loadGuildDocs() {
    const baseDir = path.join(__dirname, 'n8n_guilds');
    const Rule = fs.readFileSync(path.join(baseDir, 'Rule'), 'utf-8');
    return `ƒê√¢y l√† quy t√°c tr·∫£ l·ªùi:\n${Rule}.`
}

let guildKnowledge = '';
loadGuildDocs().then(data => {
    guildKnowledge = data;
    console.log('‚úÖ Loaded n8n guild docs');
});

app.post('/chat', upload.single('image'), async (req, res) => {
    try {
        const userPrompt = req.body.prompt || '';
        const sessionId = req.ip || 'default-session';

        let history = await ChatHistory.findOne({ sessionId });
        if (!history) {
            history = new ChatHistory({
                sessionId,
                messages: [
                    {
                        role: 'system',
                        content: `B·∫°n l√† m·ªôt tr·ª£ l√Ω AI chuy√™n v·ªÅ n8n. Khi vi·∫øt code json n8n h√£y lu√¥n ƒë·ªÉ n√≥ b√™n trong \`\`\`json \`\`\`. D∆∞·ªõi ƒë√¢y l√† t√†i li·ªáu tham kh·∫£o:\n${guildKnowledge}.`

                    }
                ]
            });
        }

        // T·∫°o user message v·ªõi metadata
        let userMessage = {
            role: 'user',
            content: userPrompt,
            metadata: {
                detectedJsonBlocks: [],
                hasFile: false,
                fileInfo: null
            }
        };

        if (req.file) {

            if (req.file.mimetype.startsWith('image/')) {
                const base64Image = fs.readFileSync(req.file.path, { encoding: 'base64' });
                userMessage.content = [
                    { type: 'text', text: userPrompt },
                    { type: 'image_url', image_url: { url: `data:image/jpeg;base64,${base64Image}` } }
                ];

                // l∆∞u ·∫£nh v√†o metadata
                userMessage.metadata.fileInfo = {
                    type: 'image',
                    name: req.file.originalname,
                    mimetype: req.file.mimetype,
                    size: req.file.size,
                    base64Data: `data:${req.file.mimetype};base64,${base64Image}`,
                };
            } else {
                let fileData = "";

                switch (req.file.mimetype) {
                    case 'application/pdf':
                        const pdfBuffer = fs.readFileSync(req.file.path);
                        const pdfData = await pdfParse(pdfBuffer);
                        fileData = pdfData.text;
                        break;

                    case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': // docx
                        const docxBuffer = fs.readFileSync(req.file.path);
                        const docxResult = await mammoth.extractRawText({ buffer: docxBuffer });
                        fileData = docxResult.value;
                        break;

                    case 'text/plain':
                        fileData = fs.readFileSync(req.file.path, 'utf8');//txt
                        break;

                    case 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': // xlsx
                        const workbook = xlsx.readFile(req.file.path);
                        const sheetName = workbook.SheetNames[0];
                        fileData = xlsx.utils.sheet_to_csv(workbook.Sheets[sheetName]);
                        break;

                    default:
                        fileData = "[‚ö†Ô∏è Lo·∫°i file ch∆∞a h·ªó tr·ª£ ƒë·ªçc tr·ª±c ti·∫øp]";
                }

                userMessage.content = [
                    { type: 'text', text: userPrompt },
                    {
                        type: 'text',
                        text: `üìÑ T·ªáp: ${req.file.originalname} (${req.file.size} bytes)\n\nN·ªôi dung:\n${fileData}`
                    }
                ];

                // l∆∞u th√¥ng tin file
                userMessage.metadata.fileInfo = {
                    type: 'document',
                    name: req.file.originalname,
                    mimetype: req.file.mimetype,
                    size: req.file.size,
                    content: fileData
                };
            }
            userMessage.metadata.hasFile = true;
            fs.unlinkSync(req.file.path); // X√≥a file t·∫°m sau khi ƒë·ªçc
        }


        // Th√™m user message v√†o history
        history.messages.push(userMessage);

        // Gi·ªõi h·∫°n l·∫°i l·ªãch s·ª≠
        let limitedMessages = [];
        if (history.messages.length > 0) {
            const systemMsg = history.messages.find(msg => msg.role === 'system');
            const otherMsgs = history.messages.filter(msg => msg.role !== 'system');
            const lastMessages = otherMsgs.slice(-10);
            limitedMessages = systemMsg ? [systemMsg, ...lastMessages] : lastMessages;
        }

        //T·∫°o tool
        const tools = [
            {
                type: "function",
                function: {
                    name: "searchPinecone",
                    description: "Tra c·ª©u d·ªØ li·ªáu n8n ƒë√£ nh√∫ng trong Pinecone",
                    parameters: {
                        type: "object",
                        properties: {
                            query: {
                                type: "string",
                                description: "C√¢u h·ªèi ho·∫∑c t·ª´ kh√≥a ƒë·ªÉ t√¨m trong Pinecone"
                            },
                            topK: {
                                type: "number",
                                description: "S·ªë l∆∞·ª£ng k·∫øt qu·∫£ c·∫ßn l·∫•y",
                                default: 5
                            }
                        },
                        required: ["query"]
                    }
                }
            }
        ];

        // G·ª≠i l√™n OpenAI
        const chatCompletion = await openai.chat.completions.create({
            model: "gpt-5-mini",
            messages: limitedMessages.map(msg => ({
                role: msg.role,
                content: msg.content
            })),
            tools: tools,
            max_completion_tokens: 3000
        });
        //Respond c·ªßa openai, c√≥ th·ªÉ l√† tr·∫£ l·ªùi tr·ª±c ti·∫øp ho·∫∑c call toool
        const choice = chatCompletion.choices[0].message;
        //check xem ai t√¨m c√°i g√¨, ho·∫∑c tr·∫£ l·ªùi c√°i g√¨
        console.log("ai ƒëi t√¨m m·∫•y c√°i n√†y", JSON.stringify(choice, null, 2));


        //n·∫øu d√πng tool
        let aiMessage;
        if (choice.tool_calls) {
            console.log('ai ƒë√£ d√πng tool')
            for (const toolCall of choice.tool_calls) {
                if (toolCall.function?.name === "searchPinecone") {
                    const args = JSON.parse(toolCall.function.arguments);
                    const embeddingQuery = await openai.embeddings.create({
                        model: "text-embedding-3-small",
                        input: args.query,
                    });
                    const vector = embeddingQuery.data[0].embedding;

                    const pc = new Pinecone({ apiKey: process.env.PINECONE_API_KEY });
                    const namespace = pc.index(process.env.INDEX_NAME, process.env.INDEX_HOST).namespace(process.env.namespace);

                    const pineconeRes = await namespace.query({
                        vector,
                        topK: args.topK || 10,
                        includeMetadata: true
                    });

                    //check xem ai t√¨m ƒëc c√°i g√¨
                    console.log("Pinecone matches:", JSON.stringify(pineconeRes.matches, null, 2));

                    const PineconeData = pineconeRes.matches
                        ?.map(m => m.metadata.text || "")
                        .filter(Boolean)
                        .join("\n\n");

                    const SupMessages = [
                        ...limitedMessages,
                        choice, // assistant message c√≥ tool_calls
                        {
                            role: "tool",
                            tool_call_id: choice.tool_calls[0].id,
                            content: PineconeData
                        }
                    ];

                    //G·ªçi l·∫°i AI ƒë·ªÉ tr·∫£ l·ªùi ra m√†n
                    const followUp = await openai.chat.completions.create({
                        model: "gpt-4.1-mini-2025-04-14",
                        messages: SupMessages,
                    });
                    aiMessage = followUp.choices[0].message;//tr·∫£ l·ªùi d√πng tool
                }
            }
        } else {
            aiMessage = choice;//tr·∫£ l·ªùi kh√¥ng d√πng tool
        }

        // X·ª¨ L√ù AI RESPONSE: Extract JSON v√† convert th√†nh Mermaid
        const detectedJsonBlocks = extractJsonFromText(aiMessage.content);

        // Convert t·ª´ng JSON block th√†nh Mermaid
        for (let block of detectedJsonBlocks) {
            try {
                const mermaidCode = await convertJsonToMermaid(block.parsed);
                block.mermaidCode = mermaidCode;
            } catch (error) {
                console.error('‚ùå Error converting to Mermaid:', error.message);
                block.mermaidCode = null;
            }
        }

        // T·∫°o AI message v·ªõi metadata
        const AiResponse = {
            role: 'assistant',
            content: aiMessage.content,
            metadata: {
                detectedJsonBlocks: detectedJsonBlocks,
                hasImage: false
            }
        };

        // Th√™m AI message v√†o history
        history.messages.push(AiResponse);

        // L∆∞u l·∫°i v√†o MongoDB
        await history.save();

        // Tr·∫£ v·ªÅ response c√≥ metadata
        res.json({
            reply: aiMessage.content,
            metadata: {
                detectedJsonBlocks: detectedJsonBlocks
            }
        });

    } catch (err) {
        console.error(err);
        res.status(500).json({ error: 'AI L·ªói R·ªìi' });
    }
});

app.listen(3000, () => {
    console.log('Server ƒëang ch·∫°y v√®o v√®o ·ªü c·ªïng http://localhost:3000');
});
